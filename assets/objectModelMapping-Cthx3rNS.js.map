{"version":3,"file":"objectModelMapping-Cthx3rNS.js","sources":["../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/gltfPathToObjectConverter.js","../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/objectModelMapping.js"],"sourcesContent":["/**\n * A converter that takes a glTF Object Model JSON Pointer\n * and transforms it into an ObjectAccessorContainer, allowing\n * objects referenced in the glTF to be associated with their\n * respective Babylon.js objects.\n */\nexport class GLTFPathToObjectConverter {\n    constructor(_gltf, _infoTree) {\n        this._gltf = _gltf;\n        this._infoTree = _infoTree;\n    }\n    /**\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\n     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\n     * <assetIndex> := <digit> | <name>\n     * <propertyPath> := <extensionPath> | <standardPath>\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\n     * <standardPath> := <name> | <name>/<standardPath>\n     * <name> := W+\n     * <digit> := D+\n     *\n     * Examples:\n     *  - \"/nodes/0/rotation\"\n     * - \"/nodes.length\"\n     *  - \"/materials/2/emissiveFactor\"\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\n     *\n     * @param path The path to convert\n     * @returns The object and info associated with the path\n     */\n    convert(path) {\n        let objectTree = this._gltf;\n        let infoTree = this._infoTree;\n        let target = undefined;\n        if (!path.startsWith(\"/\")) {\n            throw new Error(\"Path must start with a /\");\n        }\n        const parts = path.split(\"/\");\n        parts.shift();\n        //if the last part has \".length\" in it, separate that as an extra part\n        if (parts[parts.length - 1].includes(\".length\")) {\n            const lastPart = parts[parts.length - 1];\n            const split = lastPart.split(\".\");\n            parts.pop();\n            parts.push(...split);\n        }\n        let ignoreObjectTree = false;\n        for (const part of parts) {\n            const isLength = part === \"length\";\n            if (isLength && !infoTree.__array__) {\n                throw new Error(`Path ${path} is invalid`);\n            }\n            if (infoTree.__ignoreObjectTree__) {\n                ignoreObjectTree = true;\n            }\n            if (infoTree.__array__ && !isLength) {\n                infoTree = infoTree.__array__;\n            }\n            else {\n                infoTree = infoTree[part];\n                if (!infoTree) {\n                    throw new Error(`Path ${path} is invalid`);\n                }\n            }\n            if (!ignoreObjectTree) {\n                if (objectTree === undefined) {\n                    throw new Error(`Path ${path} is invalid`);\n                }\n                if (!isLength) {\n                    objectTree = objectTree?.[part];\n                }\n            }\n            if (infoTree.__target__ || isLength) {\n                target = objectTree;\n            }\n        }\n        return {\n            object: target,\n            info: infoTree,\n        };\n    }\n}\n//# sourceMappingURL=gltfPathToObjectConverter.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Matrix, Quaternion, Vector2 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\nimport { Color4 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\nimport { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter.js\";\nconst nodesTree = {\n    length: {\n        type: \"number\",\n        get: (nodes) => nodes.length,\n        getTarget: (nodes) => nodes.map((node) => node._babylonTransformNode),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {\n        __target__: true,\n        translation: {\n            type: \"Vector3\",\n            get: (node) => node._babylonTransformNode?.position,\n            set: (value, node) => node._babylonTransformNode?.position.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"position\"],\n        },\n        rotation: {\n            type: \"Quaternion\",\n            get: (node) => node._babylonTransformNode?.rotationQuaternion,\n            set: (value, node) => node._babylonTransformNode?.rotationQuaternion?.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"rotationQuaternion\"],\n        },\n        scale: {\n            type: \"Vector3\",\n            get: (node) => node._babylonTransformNode?.scaling,\n            set: (value, node) => node._babylonTransformNode?.scaling.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"scaling\"],\n        },\n        weights: {\n            length: {\n                type: \"number\",\n                get: (node) => node._numMorphTargets,\n                getTarget: (node) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            __array__: {\n                __target__: true,\n                type: \"number\",\n                get: (node, index) => (index !== undefined ? node._primitiveBabylonMeshes?.[0].morphTargetManager?.getTarget(index).influence : undefined),\n                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n                getTarget: (node) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            type: \"number[]\",\n            get: (node, index) => [0], // TODO: get the weights correctly\n            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"influence\"],\n        },\n        // readonly!\n        matrix: {\n            type: \"Matrix\",\n            get: (node) => Matrix.Compose(node._babylonTransformNode?.scaling, node._babylonTransformNode?.rotationQuaternion, node._babylonTransformNode?.position),\n            getTarget: (node) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        globalMatrix: {\n            type: \"Matrix\",\n            get: (node) => {\n                const matrix = Matrix.Identity();\n                // RHS/LHS support\n                let rootNode = node.parent;\n                while (rootNode && rootNode.parent) {\n                    rootNode = rootNode.parent;\n                }\n                const forceUpdate = node._babylonTransformNode?.position._isDirty || node._babylonTransformNode?.rotationQuaternion?._isDirty || node._babylonTransformNode?.scaling._isDirty;\n                if (rootNode) {\n                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix\n                    // This will provide the global matrix, ignoring the RHS->LHS conversion\n                    const rootMatrix = rootNode._babylonTransformNode?.computeWorldMatrix(true).invert();\n                    if (rootMatrix) {\n                        node._babylonTransformNode?.computeWorldMatrix(forceUpdate)?.multiplyToRef(rootMatrix, matrix);\n                    }\n                }\n                else if (node._babylonTransformNode) {\n                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));\n                }\n                return matrix;\n            },\n            getTarget: (node) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        extensions: {\n            EXT_lights_ies: {\n                multiplier: {\n                    type: \"number\",\n                    get: (node) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.intensity;\n                    },\n                    getTarget: (node) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.intensity = value;\n                            }\n                        }\n                    },\n                },\n                color: {\n                    type: \"Color3\",\n                    get: (node) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.diffuse;\n                    },\n                    getTarget: (node) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.diffuse = value;\n                            }\n                        }\n                    },\n                },\n            },\n        },\n    },\n};\nconst animationsTree = {\n    length: {\n        type: \"number\",\n        get: (animations) => animations.length,\n        getTarget: (animations) => animations.map((animation) => animation._babylonAnimationGroup),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\nconst meshesTree = {\n    length: {\n        type: \"number\",\n        get: (meshes) => meshes.length,\n        getTarget: (meshes) => meshes.map((mesh) => mesh.primitives[0]._instanceData?.babylonSourceMesh),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\nconst camerasTree = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoLeft ?? 0, camera._babylonCamera?.orthoRight ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoLeft = value.x;\n                        camera._babylonCamera.orthoRight = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoLeft\", () => \"orthoRight\"],\n            },\n            ymag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoBottom ?? 0, camera._babylonCamera?.orthoTop ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoBottom = value.x;\n                        camera._babylonCamera.orthoTop = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoBottom\", () => \"orthoTop\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.maxZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.minZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n        perspective: {\n            aspectRatio: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.getEngine().getAspectRatio(camera._babylonCamera),\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"aspectRatio\"],\n                isReadOnly: true, // might not be the case for glTF?\n            },\n            yfov: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.fov,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.fov = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"fov\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.maxZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.minZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n    },\n};\nconst materialsTree = {\n    __array__: {\n        __target__: true,\n        emissiveFactor: {\n            type: \"Color3\",\n            get: (material, index, payload) => _GetMaterial(material, index, payload).emissiveColor,\n            set: (value, material, index, payload) => _GetMaterial(material, index, payload).emissiveColor.copyFrom(value),\n            getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n            getPropertyName: [() => \"emissiveColor\"],\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: _GenerateTextureMap(\"emissiveTexture\"),\n            },\n        },\n        normalTexture: {\n            scale: {\n                type: \"number\",\n                get: (material, index, payload) => _GetTexture(material, payload, \"bumpTexture\")?.level,\n                set: (value, material, index, payload) => {\n                    const texture = _GetTexture(material, payload, \"bumpTexture\");\n                    if (texture) {\n                        texture.level = value;\n                    }\n                },\n                getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n                getPropertyName: [() => \"level\"],\n            },\n            extensions: {\n                KHR_texture_transform: _GenerateTextureMap(\"bumpTexture\"),\n            },\n        },\n        occlusionTexture: {\n            strength: {\n                type: \"number\",\n                get: (material, index, payload) => _GetMaterial(material, index, payload).ambientTextureStrength,\n                set: (value, material, index, payload) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.ambientTextureStrength = value;\n                    }\n                },\n                getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n                getPropertyName: [() => \"ambientTextureStrength\"],\n            },\n            extensions: {\n                KHR_texture_transform: _GenerateTextureMap(\"ambientTexture\"),\n            },\n        },\n        pbrMetallicRoughness: {\n            baseColorFactor: {\n                type: \"Color4\",\n                get: (material, index, payload) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    return Color4.FromColor3(mat.albedoColor, mat.alpha);\n                },\n                set: (value, material, index, payload) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    mat.albedoColor.set(value.r, value.g, value.b);\n                    mat.alpha = value.a;\n                },\n                getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n                // This is correct on the animation level, but incorrect as a single property of a type Color4\n                getPropertyName: [() => \"albedoColor\", () => \"alpha\"],\n            },\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: _GenerateTextureMap(\"albedoTexture\"),\n                },\n            },\n            metallicFactor: {\n                type: \"number\",\n                get: (material, index, payload) => _GetMaterial(material, index, payload).metallic,\n                set: (value, material, index, payload) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.metallic = value;\n                    }\n                },\n                getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n                getPropertyName: [() => \"metallic\"],\n            },\n            roughnessFactor: {\n                type: \"number\",\n                get: (material, index, payload) => _GetMaterial(material, index, payload).roughness,\n                set: (value, material, index, payload) => {\n                    const mat = _GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.roughness = value;\n                    }\n                },\n                getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n                getPropertyName: [() => \"roughness\"],\n            },\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: _GenerateTextureMap(\"metallicTexture\"),\n                },\n            },\n        },\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).anisotropy.intensity,\n                    set: (value, material, index, payload) => {\n                        _GetMaterial(material, index, payload).anisotropy.intensity = value;\n                    },\n                    getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.intensity\"],\n                },\n                anisotropyRotation: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).anisotropy.angle,\n                    set: (value, material, index, payload) => {\n                        _GetMaterial(material, index, payload).anisotropy.angle = value;\n                    },\n                    getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.angle\"],\n                },\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"anisotropy\", \"texture\"),\n                    },\n                },\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).clearCoat.intensity,\n                    set: (value, material, index, payload) => {\n                        _GetMaterial(material, index, payload).clearCoat.intensity = value;\n                    },\n                    getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.intensity\"],\n                },\n                clearcoatRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).clearCoat.roughness,\n                    set: (value, material, index, payload) => {\n                        _GetMaterial(material, index, payload).clearCoat.roughness = value;\n                    },\n                    getTarget: (material, index, payload) => _GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.roughness\"],\n                },\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"clearCoat\", \"texture\"),\n                    },\n                },\n                clearcoatNormalTexture: {\n                    scale: {\n                        type: \"number\",\n                        get: (material, index, payload) => _GetMaterial(material, index, payload).clearCoat.bumpTexture?.level,\n                        getTarget: _GetMaterial,\n                        set: (value, material, index, payload) => (_GetMaterial(material, index, payload).clearCoat.bumpTexture.level = value),\n                    },\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"clearCoat\", \"bumpTexture\"),\n                    },\n                },\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"clearCoat\", \"textureRoughness\"),\n                    },\n                },\n            },\n            KHR_materials_dispersion: {\n                dispersion: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.dispersion,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.dispersion = value),\n                },\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).emissiveIntensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).emissiveIntensity = value),\n                },\n            },\n            KHR_materials_ior: {\n                ior: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).indexOfRefraction,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).indexOfRefraction = value),\n                },\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).iridescence.intensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).iridescence.intensity = value),\n                },\n                iridescenceIor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).iridescence.indexOfRefraction,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).iridescence.indexOfRefraction = value),\n                },\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"iridescence\", \"texture\"),\n                    },\n                },\n                iridescenceThicknessMaximum: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).iridescence.maximumThickness,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).iridescence.maximumThickness = value),\n                },\n                iridescenceThicknessMinimum: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).iridescence.minimumThickness,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).iridescence.minimumThickness = value),\n                },\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"iridescence\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).sheen.color,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => _GetMaterial(material, index, payload).sheen.color.copyFrom(value),\n                },\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"sheen\", \"texture\"),\n                    },\n                },\n                sheenRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).sheen.intensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).sheen.intensity = value),\n                },\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"sheen\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_specular: {\n                specularFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).metallicF0Factor,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).metallicF0Factor = value),\n                    getPropertyName: [() => \"metallicF0Factor\"],\n                },\n                specularColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).metallicReflectanceColor,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => _GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),\n                    getPropertyName: [() => \"metallicReflectanceColor\"],\n                },\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"metallicReflectanceTexture\"),\n                    },\n                },\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"reflectanceTexture\"),\n                    },\n                },\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.refractionIntensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.refractionIntensity = value),\n                    getPropertyName: [() => \"subSurface.refractionIntensity\"],\n                },\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"subSurface\", \"refractionIntensityTexture\"),\n                    },\n                },\n            },\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.translucencyIntensity,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.translucencyIntensity = value),\n                },\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"subSurface\", \"translucencyIntensityTexture\"),\n                    },\n                },\n                diffuseTransmissionColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.translucencyColor,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => value && _GetMaterial(material, index, payload).subSurface.translucencyColor?.copyFrom(value),\n                },\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"subSurface\", \"translucencyColorTexture\"),\n                    },\n                },\n            },\n            KHR_materials_volume: {\n                attenuationColor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.tintColor,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => _GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value),\n                },\n                attenuationDistance: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.tintColorAtDistance,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value),\n                },\n                thicknessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => _GetMaterial(material, index, payload).subSurface.maximumThickness,\n                    getTarget: _GetMaterial,\n                    set: (value, material, index, payload) => (_GetMaterial(material, index, payload).subSurface.maximumThickness = value),\n                },\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: _GenerateTextureMap(\"subSurface\", \"thicknessTexture\"),\n                    },\n                },\n            },\n        },\n    },\n};\nconst extensionsTree = {\n    KHR_lights_punctual: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonLight),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light) => light._babylonLight?.diffuse,\n                    set: (value, light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.intensity,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"intensity\"],\n                },\n                range: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.range,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.range = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"range\"],\n                },\n                spot: {\n                    innerConeAngle: {\n                        type: \"number\",\n                        get: (light) => light._babylonLight?.innerAngle,\n                        set: (value, light) => (light._babylonLight ? (light._babylonLight.innerAngle = value) : undefined),\n                        getTarget: (light) => light._babylonLight,\n                        getPropertyName: [(_light) => \"innerConeAngle\"],\n                    },\n                    outerConeAngle: {\n                        type: \"number\",\n                        get: (light) => light._babylonLight?.angle,\n                        set: (value, light) => (light._babylonLight ? (light._babylonLight.angle = value) : undefined),\n                        getTarget: (light) => light._babylonLight,\n                        getPropertyName: [(_light) => \"outerConeAngle\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_ies: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonLight),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n        },\n    },\n    EXT_lights_image_based: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonTexture),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonTexture?.level,\n                    set: (value, light) => {\n                        if (light._babylonTexture)\n                            light._babylonTexture.level = value;\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n                rotation: {\n                    type: \"Quaternion\",\n                    get: (light) => light._babylonTexture && Quaternion.FromRotationMatrix(light._babylonTexture?.getReflectionTextureMatrix()),\n                    set: (value, light) => {\n                        if (!light._babylonTexture)\n                            return;\n                        // Invert the rotation so that positive rotation is counter-clockwise.\n                        if (!light._babylonTexture.getScene()?.useRightHandedSystem) {\n                            value = Quaternion.Inverse(value);\n                        }\n                        Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n            },\n        },\n    },\n};\nfunction _GetTexture(material, payload, textureType, textureInObject) {\n    const babylonMaterial = _GetMaterial(material, payload);\n    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];\n}\nfunction _GetMaterial(material, _index, payload) {\n    return material._data?.[payload?.fillMode ?? Constants.MATERIAL_TriangleFillMode]?.babylonMaterial;\n}\nfunction _GenerateTextureMap(textureType, textureInObject) {\n    return {\n        offset: {\n            componentsCount: 2,\n            // assuming two independent values for u and v, and NOT a Vector2\n            type: \"Vector2\",\n            get: (material, _index, payload) => {\n                const texture = _GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uOffset, texture?.vOffset);\n            },\n            getTarget: _GetMaterial,\n            set: (value, material, _index, payload) => {\n                const texture = _GetTexture(material, payload, textureType, textureInObject);\n                (texture.uOffset = value.x), (texture.vOffset = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uOffset`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vOffset`,\n            ],\n        },\n        rotation: {\n            type: \"number\",\n            get: (material, _index, payload) => _GetTexture(material, payload, textureType, textureInObject)?.wAng,\n            getTarget: _GetMaterial,\n            set: (value, material, _index, payload) => (_GetTexture(material, payload, textureType, textureInObject).wAng = value),\n            getPropertyName: [() => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.wAng`],\n        },\n        scale: {\n            componentsCount: 2,\n            type: \"Vector2\",\n            get: (material, _index, payload) => {\n                const texture = _GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uScale, texture?.vScale);\n            },\n            getTarget: _GetMaterial,\n            set: (value, material, index, payload) => {\n                const texture = _GetTexture(material, payload, textureType, textureInObject);\n                (texture.uScale = value.x), (texture.vScale = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uScale`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vScale`,\n            ],\n        },\n    };\n}\nconst objectModelMapping = {\n    cameras: camerasTree,\n    nodes: nodesTree,\n    materials: materialsTree,\n    extensions: extensionsTree,\n    animations: animationsTree,\n    meshes: meshesTree,\n};\n/**\n * get a path-to-object converter for the given glTF tree\n * @param gltf the glTF tree to use\n * @returns a path-to-object converter for the given glTF tree\n */\nexport function GetPathToObjectConverter(gltf) {\n    return new GLTFPathToObjectConverter(gltf, objectModelMapping);\n}\n/**\n * This function will return the object accessor for the given key in the object model\n * If the key is not found, it will return undefined\n * @param key the key to get the mapping for, for example /materials/\\{\\}/emissiveFactor\n * @returns an object accessor for the given key, or undefined if the key is not found\n */\nexport function GetMappingForKey(key) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that current is an object accessor\n    if (current && current.type && current.get) {\n        return current;\n    }\n    return undefined;\n}\n/**\n * Set interpolation for a specific key in the object model\n * @param key the key to set, for example /materials/\\{\\}/emissiveFactor\n * @param interpolation the interpolation elements array\n */\nexport function SetInterpolationForKey(key, interpolation) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that the current object is an object accessor\n    if (current && current.type && current.get) {\n        current.interpolation = interpolation;\n    }\n}\n/**\n * This will ad a new object accessor in the object model at the given key.\n * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)\n * @param key the key to add the object accessor at. For example /cameras/\\{\\}/perspective/aspectRatio\n * @param accessor the object accessor to add\n */\nexport function AddObjectAccessorToKey(key, accessor) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        if (!current[part]) {\n            if (part === \"?\") {\n                current.__ignoreObjectTree__ = true;\n                continue;\n            }\n            current[part] = {};\n            // if the part is __array__ then add the __target__ property\n            if (part === \"__array__\") {\n                current[part].__target__ = true;\n            }\n        }\n        current = current[part];\n    }\n    Object.assign(current, accessor);\n}\n//# sourceMappingURL=objectModelMapping.js.map"],"names":["GLTFPathToObjectConverter","_gltf","_infoTree","path","objectTree","infoTree","target","parts","split","ignoreObjectTree","part","isLength","nodesTree","nodes","node","_a","value","_b","index","Matrix","_c","matrix","rootNode","forceUpdate","_d","rootMatrix","_e","_g","_f","child","SpotLight","light","animationsTree","animations","animation","meshesTree","meshes","mesh","camerasTree","camera","Vector2","materialsTree","material","payload","_GetMaterial","_GenerateTextureMap","_GetTexture","texture","mat","Color4","extensionsTree","lights","_lights","_light","Quaternion","textureType","textureInObject","babylonMaterial","_index","Constants","objectModelMapping","GetPathToObjectConverter","gltf","GetMappingForKey","key","keyParts","current","SetInterpolationForKey","interpolation","AddObjectAccessorToKey","accessor"],"mappings":"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","x_google_ignoreList":[0,1]}