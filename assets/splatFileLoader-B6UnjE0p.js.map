{"version":3,"file":"splatFileLoader-B6UnjE0p.js","sources":["../../node_modules/@babylonjs/loaders/SPLAT/splatFileLoader.js"],"sourcesContent":["import { RegisterSceneLoaderPlugin } from \"@babylonjs/core/Loading/sceneLoader.js\";\nimport { SPLATFileLoaderMetadata } from \"./splatFileLoader.metadata.js\";\nimport { GaussianSplattingMesh } from \"@babylonjs/core/Meshes/GaussianSplatting/gaussianSplattingMesh.js\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { PointsCloudSystem } from \"@babylonjs/core/Particles/pointsCloudSystem.js\";\nimport { Color4 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData.js\";\nimport { Scalar } from \"@babylonjs/core/Maths/math.scalar.js\";\n/**\n * Indicator of the parsed ply buffer. A standard ready to use splat or an array of positions for a point cloud\n */\nvar Mode;\n(function (Mode) {\n    Mode[Mode[\"Splat\"] = 0] = \"Splat\";\n    Mode[Mode[\"PointCloud\"] = 1] = \"PointCloud\";\n    Mode[Mode[\"Mesh\"] = 2] = \"Mesh\";\n    Mode[Mode[\"Reject\"] = 3] = \"Reject\";\n})(Mode || (Mode = {}));\n/**\n * @experimental\n * SPLAT file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class SPLATFileLoader {\n    /**\n     * Creates loader for gaussian splatting files\n     * @param loadingOptions options for loading and parsing splat and PLY files.\n     */\n    constructor(loadingOptions = SPLATFileLoader._DefaultLoadingOptions) {\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = SPLATFileLoaderMetadata.name;\n        this._assetContainer = null;\n        /**\n         * Defines the extensions the splat loader is able to load.\n         * force data to come in as an ArrayBuffer\n         */\n        this.extensions = SPLATFileLoaderMetadata.extensions;\n        this._loadingOptions = loadingOptions;\n    }\n    /** @internal */\n    createPlugin(options) {\n        return new SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);\n    }\n    /**\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the gaussian splatting data to load\n     * @param rootUrl root url to load from\n     * @param onProgress callback called while file is loading\n     * @param fileName Defines the name of the file to load\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\n     */\n    async importMeshAsync(meshesNames, scene, data, rootUrl, onProgress, fileName) {\n        return this._parse(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            };\n        });\n    }\n    static _BuildPointCloud(pointcloud, data) {\n        if (!data.byteLength) {\n            return false;\n        }\n        const uBuffer = new Uint8Array(data);\n        const fBuffer = new Float32Array(data);\n        // parsed array contains room for position(3floats), normal(3floats), color (4b), quantized quaternion (4b)\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n        const vertexCount = uBuffer.length / rowLength;\n        const pointcloudfunc = function (particle, i) {\n            const x = fBuffer[8 * i + 0];\n            const y = fBuffer[8 * i + 1];\n            const z = fBuffer[8 * i + 2];\n            particle.position = new Vector3(x, y, z);\n            const r = uBuffer[rowLength * i + 24 + 0] / 255;\n            const g = uBuffer[rowLength * i + 24 + 1] / 255;\n            const b = uBuffer[rowLength * i + 24 + 2] / 255;\n            particle.color = new Color4(r, g, b, 1);\n        };\n        pointcloud.addPoints(vertexCount, pointcloudfunc);\n        return true;\n    }\n    static _BuildMesh(scene, parsedPLY) {\n        const mesh = new Mesh(\"PLYMesh\", scene);\n        const uBuffer = new Uint8Array(parsedPLY.data);\n        const fBuffer = new Float32Array(parsedPLY.data);\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n        const vertexCount = uBuffer.length / rowLength;\n        const positions = [];\n        const vertexData = new VertexData();\n        for (let i = 0; i < vertexCount; i++) {\n            const x = fBuffer[8 * i + 0];\n            const y = fBuffer[8 * i + 1];\n            const z = fBuffer[8 * i + 2];\n            positions.push(x, y, z);\n        }\n        if (parsedPLY.hasVertexColors) {\n            const colors = new Float32Array(vertexCount * 4);\n            for (let i = 0; i < vertexCount; i++) {\n                const r = uBuffer[rowLength * i + 24 + 0] / 255;\n                const g = uBuffer[rowLength * i + 24 + 1] / 255;\n                const b = uBuffer[rowLength * i + 24 + 2] / 255;\n                colors[i * 4 + 0] = r;\n                colors[i * 4 + 1] = g;\n                colors[i * 4 + 2] = b;\n                colors[i * 4 + 3] = 1;\n            }\n            vertexData.colors = colors;\n        }\n        vertexData.positions = positions;\n        vertexData.indices = parsedPLY.faces;\n        vertexData.applyToMesh(mesh);\n        return mesh;\n    }\n    _parseSPZ(data, scene) {\n        const ubuf = new Uint8Array(data);\n        const ubufu32 = new Uint32Array(data);\n        // debug infos\n        const splatCount = ubufu32[2];\n        const shDegree = ubuf[12];\n        const fractionalBits = ubuf[13];\n        //const flags = ubuf[14];\n        const reserved = ubuf[15];\n        // check magic and version\n        if (reserved || ubufu32[0] != 0x5053474e || ubufu32[1] != 2) {\n            // reserved must be 0\n            return new Promise((resolve) => {\n                resolve({ mode: 3 /* Mode.Reject */, data: buffer, hasVertexColors: false });\n            });\n        }\n        const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\n        const buffer = new ArrayBuffer(rowOutputLength * splatCount);\n        const positionScale = 1.0 / (1 << fractionalBits);\n        const int32View = new Int32Array(1);\n        const uint8View = new Uint8Array(int32View.buffer);\n        const read24bComponent = function (u8, offset) {\n            uint8View[0] = u8[offset + 0];\n            uint8View[1] = u8[offset + 1];\n            uint8View[2] = u8[offset + 2];\n            uint8View[3] = u8[offset + 2] & 0x80 ? 0xff : 0x00;\n            return int32View[0] * positionScale;\n        };\n        let byteOffset = 16;\n        const position = new Float32Array(buffer);\n        const scale = new Float32Array(buffer);\n        const rgba = new Uint8ClampedArray(buffer);\n        const rot = new Uint8ClampedArray(buffer);\n        let coordinateSign = 1;\n        let quaternionOffset = 0;\n        if (!this._loadingOptions.flipY) {\n            coordinateSign = -1;\n            quaternionOffset = 255;\n        }\n        // positions\n        for (let i = 0; i < splatCount; i++) {\n            position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);\n            position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);\n            position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);\n            byteOffset += 9;\n        }\n        // colors\n        const SH_C0 = 0.282;\n        for (let i = 0; i < splatCount; i++) {\n            for (let component = 0; component < 3; component++) {\n                const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];\n                // 0.15 is hard coded value from spz\n                // Scale factor for DC color components. To convert to RGB, we should multiply by 0.282, but it can\n                // be useful to represent base colors that are out of range if the higher spherical harmonics bands\n                // bring them back into range so we multiply by a smaller value.\n                const value = (byteValue - 127.5) / (0.15 * 255);\n                rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + SH_C0 * value) * 255, 0, 255);\n            }\n            rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];\n        }\n        byteOffset += splatCount * 4;\n        // scales\n        for (let i = 0; i < splatCount; i++) {\n            scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16.0 - 10.0);\n            scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16.0 - 10.0);\n            scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16.0 - 10.0);\n            byteOffset += 3;\n        }\n        // convert quaternion\n        for (let i = 0; i < splatCount; i++) {\n            const x = ubuf[byteOffset + 0];\n            const y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;\n            const z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;\n            const nx = x / 127.5 - 1;\n            const ny = y / 127.5 - 1;\n            const nz = z / 127.5 - 1;\n            rot[i * 32 + 28 + 1] = x;\n            rot[i * 32 + 28 + 2] = y;\n            rot[i * 32 + 28 + 3] = z;\n            const v = 1 - (nx * nx + ny * ny + nz * nz);\n            rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;\n            byteOffset += 3;\n        }\n        //SH\n        if (shDegree) {\n            // shVectorCount is : 3 for dim = 1, 8 for dim = 2 and 15 for dim = 3\n            // number of vec3 vector needed per splat\n            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1; // minus 1 because sh0 is color\n            // number of component values : 3 per vector3 (45)\n            const shComponentCount = shVectorCount * 3;\n            const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\n            let shIndexRead = byteOffset;\n            // sh is an array of uint8array that will be used to create sh textures\n            const sh = [];\n            const engine = scene.getEngine();\n            const width = engine.getCaps().maxTextureSize;\n            const height = Math.ceil(splatCount / width);\n            // create array for the number of textures needed.\n            for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\n                const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\n                sh.push(texture);\n            }\n            for (let i = 0; i < splatCount; i++) {\n                for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {\n                    const shValue = ubuf[shIndexRead++];\n                    const textureIndex = Math.floor(shIndexWrite / 16);\n                    const shArray = sh[textureIndex];\n                    const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                    const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                    shArray[byteIndexInTexture + offsetPerSplat] = shValue;\n                }\n            }\n            return new Promise((resolve) => {\n                resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, sh: sh });\n            });\n        }\n        return new Promise((resolve) => {\n            resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false });\n        });\n    }\n    _parse(meshesNames, scene, data, rootUrl) {\n        const babylonMeshesArray = []; //The mesh for babylon\n        const readableStream = new ReadableStream({\n            start(controller) {\n                controller.enqueue(new Uint8Array(data)); // Enqueue the ArrayBuffer as a Uint8Array\n                controller.close();\n            },\n        });\n        // Use GZip DecompressionStream\n        const decompressionStream = new DecompressionStream(\"gzip\");\n        const decompressedStream = readableStream.pipeThrough(decompressionStream);\n        return new Promise((resolve) => {\n            new Response(decompressedStream)\n                .arrayBuffer()\n                .then((buffer) => {\n                this._parseSPZ(buffer, scene).then((parsedSPZ) => {\n                    scene._blockEntityCollection = !!this._assetContainer;\n                    const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n                    gaussianSplatting._parentContainer = this._assetContainer;\n                    babylonMeshesArray.push(gaussianSplatting);\n                    gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);\n                    scene._blockEntityCollection = false;\n                    resolve(babylonMeshesArray);\n                });\n            })\n                .catch(() => {\n                // Catch any decompression errors\n                SPLATFileLoader._ConvertPLYToSplat(data).then(async (parsedPLY) => {\n                    scene._blockEntityCollection = !!this._assetContainer;\n                    switch (parsedPLY.mode) {\n                        case 0 /* Mode.Splat */:\n                            {\n                                const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n                                gaussianSplatting._parentContainer = this._assetContainer;\n                                babylonMeshesArray.push(gaussianSplatting);\n                                gaussianSplatting.updateData(parsedPLY.data);\n                            }\n                            break;\n                        case 1 /* Mode.PointCloud */:\n                            {\n                                const pointcloud = new PointsCloudSystem(\"PointCloud\", 1, scene);\n                                if (SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {\n                                    await pointcloud.buildMeshAsync().then((mesh) => {\n                                        babylonMeshesArray.push(mesh);\n                                    });\n                                }\n                                else {\n                                    pointcloud.dispose();\n                                }\n                            }\n                            break;\n                        case 2 /* Mode.Mesh */:\n                            {\n                                if (parsedPLY.faces) {\n                                    babylonMeshesArray.push(SPLATFileLoader._BuildMesh(scene, parsedPLY));\n                                }\n                                else {\n                                    throw new Error(\"PLY mesh doesn't contain face informations.\");\n                                }\n                            }\n                            break;\n                        default:\n                            throw new Error(\"Unsupported Splat mode\");\n                    }\n                    scene._blockEntityCollection = false;\n                    resolve(babylonMeshesArray);\n                });\n            });\n        });\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    loadAssetContainerAsync(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        this._assetContainer = container;\n        return this.importMeshAsync(null, scene, data, rootUrl)\n            .then((result) => {\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            // mesh material will be null before 1st rendered frame.\n            this._assetContainer = null;\n            return container;\n        })\n            .catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        });\n    }\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    loadAsync(scene, data, rootUrl) {\n        //Get the 3D model\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\n            // return void\n        });\n    }\n    /**\n     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer\n     */\n    static _ConvertPLYToSplat(data) {\n        const ubuf = new Uint8Array(data);\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\n        const headerEnd = \"end_header\\n\";\n        const headerEndIndex = header.indexOf(headerEnd);\n        if (headerEndIndex < 0 || !header) {\n            // standard splat\n            return new Promise((resolve) => {\n                resolve({ mode: 0 /* Mode.Splat */, data: data });\n            });\n        }\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)[1]);\n        const faceElement = /element face (\\d+)\\n/.exec(header);\n        let faceCount = 0;\n        if (faceElement) {\n            faceCount = parseInt(faceElement[1]);\n        }\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\n        let chunkCount = 0;\n        if (chunkElement) {\n            chunkCount = parseInt(chunkElement[1]);\n        }\n        let rowVertexOffset = 0;\n        let rowChunkOffset = 0;\n        const offsets = {\n            double: 8,\n            int: 4,\n            uint: 4,\n            float: 4,\n            short: 2,\n            ushort: 2,\n            uchar: 1,\n            list: 0,\n        };\n        let ElementMode;\n        (function (ElementMode) {\n            ElementMode[ElementMode[\"Vertex\"] = 0] = \"Vertex\";\n            ElementMode[ElementMode[\"Chunk\"] = 1] = \"Chunk\";\n        })(ElementMode || (ElementMode = {}));\n        let chunkMode = 1 /* ElementMode.Chunk */;\n        const vertexProperties = [];\n        const chunkProperties = [];\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\n        for (const prop of filtered) {\n            if (prop.startsWith(\"property \")) {\n                const [, type, name] = prop.split(\" \");\n                if (chunkMode == 1 /* ElementMode.Chunk */) {\n                    chunkProperties.push({ name, type, offset: rowChunkOffset });\n                    rowChunkOffset += offsets[type];\n                }\n                else if (chunkMode == 0 /* ElementMode.Vertex */) {\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\n                    rowVertexOffset += offsets[type];\n                }\n                if (!offsets[type]) {\n                    Logger.Warn(`Unsupported property type: ${type}.`);\n                }\n            }\n            else if (prop.startsWith(\"element \")) {\n                const [, type] = prop.split(\" \");\n                if (type == \"chunk\") {\n                    chunkMode = 1 /* ElementMode.Chunk */;\n                }\n                else if (type == \"vertex\") {\n                    chunkMode = 0 /* ElementMode.Vertex */;\n                }\n            }\n        }\n        const rowVertexLength = rowVertexOffset;\n        const rowChunkLength = rowChunkOffset;\n        return GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data).then((splatsData) => {\n            const dataView = new DataView(data, headerEndIndex + headerEnd.length);\n            let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;\n            // faces\n            const faces = [];\n            if (faceCount) {\n                for (let i = 0; i < faceCount; i++) {\n                    const faceVertexCount = dataView.getUint8(offset);\n                    if (faceVertexCount != 3) {\n                        continue; // only support triangles\n                    }\n                    offset += 1;\n                    for (let j = 0; j < faceVertexCount; j++) {\n                        const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true); // change face winding\n                        faces.push(vertexIndex);\n                    }\n                    offset += 12;\n                }\n            }\n            // early exit for chunked/quantized ply\n            if (chunkCount) {\n                return new Promise((resolve) => {\n                    resolve({ mode: 0 /* Mode.Splat */, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: false });\n                });\n            }\n            // count available properties. if all necessary are present then it's a splat. Otherwise, it's a point cloud\n            // if faces are found, then it's a standard mesh\n            let propertyCount = 0;\n            let propertyColorCount = 0;\n            const splatProperties = [\"x\", \"y\", \"z\", \"scale_0\", \"scale_1\", \"scale_2\", \"opacity\", \"rot_0\", \"rot_1\", \"rot_2\", \"rot_3\"];\n            const splatColorProperties = [\"red\", \"green\", \"blue\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"];\n            for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {\n                const property = vertexProperties[propertyIndex];\n                if (splatProperties.includes(property.name)) {\n                    propertyCount++;\n                }\n                if (splatColorProperties.includes(property.name)) {\n                    propertyColorCount++;\n                }\n            }\n            const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;\n            const currentMode = faceCount ? 2 /* Mode.Mesh */ : hasMandatoryProperties ? 0 /* Mode.Splat */ : 1 /* Mode.PointCloud */;\n            // parsed ready ready to be used as a splat\n            return new Promise((resolve) => {\n                resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: !!propertyColorCount });\n            });\n        });\n    }\n}\nSPLATFileLoader._DefaultLoadingOptions = {\n    keepInRam: false,\n    flipY: false,\n};\n// Add this loader into the register plugin\nRegisterSceneLoaderPlugin(new SPLATFileLoader());\n//# sourceMappingURL=splatFileLoader.js.map"],"names":["Mode","SPLATFileLoader","loadingOptions","SPLATFileLoaderMetadata","options","meshesNames","scene","data","rootUrl","onProgress","fileName","meshes","pointcloud","uBuffer","fBuffer","rowLength","vertexCount","pointcloudfunc","particle","i","x","y","z","Vector3","r","b","Color4","parsedPLY","mesh","Mesh","positions","vertexData","VertexData","colors","g","ubuf","ubufu32","splatCount","shDegree","fractionalBits","resolve","buffer","rowOutputLength","positionScale","int32View","uint8View","read24bComponent","u8","offset","byteOffset","position","scale","rgba","rot","coordinateSign","quaternionOffset","SH_C0","component","value","Scalar","nx","ny","nz","v","shComponentCount","textureCount","shIndexRead","sh","width","height","textureIndex","texture","shIndexWrite","shValue","shArray","byteIndexInTexture","offsetPerSplat","babylonMeshesArray","readableStream","controller","decompressionStream","decompressedStream","parsedSPZ","gaussianSplatting","GaussianSplattingMesh","PointsCloudSystem","container","AssetContainer","result","ex","header","headerEnd","headerEndIndex","faceElement","faceCount","chunkElement","chunkCount","rowVertexOffset","rowChunkOffset","offsets","ElementMode","chunkMode","vertexProperties","filtered","prop","type","name","Logger","rowVertexLength","rowChunkLength","splatsData","dataView","faces","faceVertexCount","j","vertexIndex","propertyCount","propertyColorCount","splatProperties","splatColorProperties","propertyIndex","property","hasMandatoryProperties","currentMode","RegisterSceneLoaderPlugin"],"mappings":"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","x_google_ignoreList":[0]}