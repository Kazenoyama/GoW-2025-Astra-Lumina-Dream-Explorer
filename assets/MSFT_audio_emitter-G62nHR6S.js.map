{"version":3,"file":"MSFT_audio_emitter-G62nHR6S.js","sources":["../../node_modules/@babylonjs/core/Animations/animationEvent.js","../../node_modules/@babylonjs/core/Audio/weightedsound.js","../../node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_audio_emitter.js"],"sourcesContent":["/**\n * Composed of a frame, and an action function\n */\nexport class AnimationEvent {\n    /**\n     * Initializes the animation event\n     * @param frame The frame for which the event is triggered\n     * @param action The event to perform when triggered\n     * @param onlyOnce Specifies if the event should be triggered only once\n     */\n    constructor(\n    /** The frame for which the event is triggered **/\n    frame, \n    /** The event to perform when triggered **/\n    action, \n    /** Specifies if the event should be triggered only once**/\n    onlyOnce) {\n        this.frame = frame;\n        this.action = action;\n        this.onlyOnce = onlyOnce;\n        /**\n         * Specifies if the animation event is done\n         */\n        this.isDone = false;\n    }\n    /** @internal */\n    _clone() {\n        return new AnimationEvent(this.frame, this.action, this.onlyOnce);\n    }\n}\n//# sourceMappingURL=animationEvent.js.map","import { Logger } from \"../Misc/logger.js\";\n/**\n * Wraps one or more Sound objects and selects one with random weight for playback.\n */\nexport class WeightedSound {\n    /**\n     * Creates a new WeightedSound from the list of sounds given.\n     * @param loop When true a Sound will be selected and played when the current playing Sound completes.\n     * @param sounds Array of Sounds that will be selected from.\n     * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\n     */\n    constructor(loop, sounds, weights) {\n        /** When true a Sound will be selected and played when the current playing Sound completes. */\n        this.loop = false;\n        this._coneInnerAngle = 360;\n        this._coneOuterAngle = 360;\n        this._volume = 1;\n        /** A Sound is currently playing. */\n        this.isPlaying = false;\n        /** A Sound is currently paused. */\n        this.isPaused = false;\n        this._sounds = [];\n        this._weights = [];\n        if (sounds.length !== weights.length) {\n            throw new Error(\"Sounds length does not equal weights length\");\n        }\n        this.loop = loop;\n        this._weights = weights;\n        // Normalize the weights\n        let weightSum = 0;\n        for (const weight of weights) {\n            weightSum += weight;\n        }\n        const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\n        for (let i = 0; i < this._weights.length; i++) {\n            this._weights[i] *= invWeightSum;\n        }\n        this._sounds = sounds;\n        for (const sound of this._sounds) {\n            sound.onEndedObservable.add(() => {\n                this._onended();\n            });\n        }\n    }\n    /**\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\n     */\n    get directionalConeInnerAngle() {\n        return this._coneInnerAngle;\n    }\n    /**\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\n     */\n    set directionalConeInnerAngle(value) {\n        if (value !== this._coneInnerAngle) {\n            if (this._coneOuterAngle < value) {\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._coneInnerAngle = value;\n            for (const sound of this._sounds) {\n                sound.directionalConeInnerAngle = value;\n            }\n        }\n    }\n    /**\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\n     */\n    get directionalConeOuterAngle() {\n        return this._coneOuterAngle;\n    }\n    /**\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\n     */\n    set directionalConeOuterAngle(value) {\n        if (value !== this._coneOuterAngle) {\n            if (value < this._coneInnerAngle) {\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._coneOuterAngle = value;\n            for (const sound of this._sounds) {\n                sound.directionalConeOuterAngle = value;\n            }\n        }\n    }\n    /**\n     * Playback volume.\n     */\n    get volume() {\n        return this._volume;\n    }\n    /**\n     * Playback volume.\n     */\n    set volume(value) {\n        if (value !== this._volume) {\n            for (const sound of this._sounds) {\n                sound.setVolume(value);\n            }\n        }\n    }\n    _onended() {\n        if (this._currentIndex !== undefined) {\n            this._sounds[this._currentIndex].autoplay = false;\n        }\n        if (this.loop && this.isPlaying) {\n            this.play();\n        }\n        else {\n            this.isPlaying = false;\n        }\n    }\n    /**\n     * Suspend playback\n     */\n    pause() {\n        if (this.isPlaying) {\n            this.isPaused = true;\n            if (this._currentIndex !== undefined) {\n                this._sounds[this._currentIndex].pause();\n            }\n        }\n    }\n    /**\n     * Stop playback\n     */\n    stop() {\n        this.isPlaying = false;\n        if (this._currentIndex !== undefined) {\n            this._sounds[this._currentIndex].stop();\n        }\n    }\n    /**\n     * Start playback.\n     * @param startOffset Position the clip head at a specific time in seconds.\n     */\n    play(startOffset) {\n        if (!this.isPaused) {\n            this.stop();\n            const randomValue = Math.random();\n            let total = 0;\n            for (let i = 0; i < this._weights.length; i++) {\n                total += this._weights[i];\n                if (randomValue <= total) {\n                    this._currentIndex = i;\n                    break;\n                }\n            }\n        }\n        const sound = this._sounds[this._currentIndex ?? 0];\n        if (sound.isReady()) {\n            sound.play(0, this.isPaused ? undefined : startOffset);\n        }\n        else {\n            sound.autoplay = true;\n        }\n        this.isPlaying = true;\n        this.isPaused = false;\n    }\n}\n//# sourceMappingURL=weightedsound.js.map","import { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { AnimationEvent } from \"@babylonjs/core/Animations/animationEvent.js\";\nimport { Sound } from \"@babylonjs/core/Audio/sound.js\";\nimport { WeightedSound } from \"@babylonjs/core/Audio/weightedsound.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry.js\";\nimport \"@babylonjs/core/Audio/audioSceneComponent.js\";\nconst NAME = \"MSFT_audio_emitter\";\n/**\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\n * !!! Experimental Extension Subject to Changes !!!\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_audio_emitter {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        this._clips = null;\n        this._emitters = null;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._clips = extension.clips;\n            this._emitters = extension.emitters;\n            ArrayItem.Assign(this._clips);\n            ArrayItem.Assign(this._emitters);\n        }\n    }\n    /**\n     * @internal\n     */\n    loadSceneAsync(context, scene) {\n        return GLTFLoader.LoadExtensionAsync(context, scene, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadSceneAsync(context, scene));\n            for (const emitterIndex of extension.emitters) {\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                if (emitter.refDistance != undefined ||\n                    emitter.maxDistance != undefined ||\n                    emitter.rolloffFactor != undefined ||\n                    emitter.distanceModel != undefined ||\n                    emitter.innerAngle != undefined ||\n                    emitter.outerAngle != undefined) {\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\n                }\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\n            }\n            return Promise.all(promises).then(() => { });\n        });\n    }\n    /**\n     * @internal\n     */\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {\n            const promises = new Array();\n            return this._loader\n                .loadNodeAsync(extensionContext, node, (babylonMesh) => {\n                for (const emitterIndex of extension.emitters) {\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                    promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\n                        for (const sound of emitter._babylonSounds) {\n                            sound.attachToMesh(babylonMesh);\n                            if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                                sound.setLocalDirectionToMesh(Vector3.Forward());\n                                sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle), 0);\n                            }\n                        }\n                    }));\n                }\n                assign(babylonMesh);\n            })\n                .then((babylonMesh) => {\n                return Promise.all(promises).then(() => {\n                    return babylonMesh;\n                });\n            });\n        });\n    }\n    /**\n     * @internal\n     */\n    loadAnimationAsync(context, animation) {\n        return GLTFLoader.LoadExtensionAsync(context, animation, this.name, (extensionContext, extension) => {\n            return this._loader.loadAnimationAsync(context, animation).then((babylonAnimationGroup) => {\n                const promises = new Array();\n                ArrayItem.Assign(extension.events);\n                for (const event of extension.events) {\n                    promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\n                }\n                return Promise.all(promises).then(() => {\n                    return babylonAnimationGroup;\n                });\n            });\n        });\n    }\n    _loadClipAsync(context, clip) {\n        if (clip._objectURL) {\n            return clip._objectURL;\n        }\n        let promise;\n        if (clip.uri) {\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\n        }\n        clip._objectURL = promise.then((data) => {\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\n        });\n        return clip._objectURL;\n    }\n    _loadEmitterAsync(context, emitter) {\n        emitter._babylonSounds = emitter._babylonSounds || [];\n        if (!emitter._babylonData) {\n            const clipPromises = new Array();\n            const name = emitter.name || `emitter${emitter.index}`;\n            const options = {\n                loop: false,\n                autoplay: false,\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\n            };\n            for (let i = 0; i < emitter.clips.length; i++) {\n                const clipContext = `/extensions/${this.name}/clips`;\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\n                clipPromises.push(this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL) => {\n                    const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\n                    sound.refDistance = emitter.refDistance || 1;\n                    sound.maxDistance = emitter.maxDistance || 256;\n                    sound.rolloffFactor = emitter.rolloffFactor || 1;\n                    sound.distanceModel = emitter.distanceModel || \"exponential\";\n                }));\n            }\n            const promise = Promise.all(clipPromises).then(() => {\n                const weights = emitter.clips.map((clip) => {\n                    return clip.weight || 1;\n                });\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n                if (emitter.innerAngle) {\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\n                }\n                if (emitter.outerAngle) {\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\n                }\n                if (emitter.volume) {\n                    weightedSound.volume = emitter.volume;\n                }\n                emitter._babylonData.sound = weightedSound;\n            });\n            emitter._babylonData = {\n                loaded: promise,\n            };\n        }\n        return emitter._babylonData.loaded;\n    }\n    _getEventAction(context, sound, action, time, startOffset) {\n        switch (action) {\n            case \"play\" /* IMSFTAudioEmitter_AnimationEventAction.play */: {\n                return (currentFrame) => {\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\n                    sound.play(frameOffset);\n                };\n            }\n            case \"stop\" /* IMSFTAudioEmitter_AnimationEventAction.stop */: {\n                return () => {\n                    sound.stop();\n                };\n            }\n            case \"pause\" /* IMSFTAudioEmitter_AnimationEventAction.pause */: {\n                return () => {\n                    sound.pause();\n                };\n            }\n            default: {\n                throw new Error(`${context}: Unsupported action ${action}`);\n            }\n        }\n    }\n    _loadAnimationEventAsync(context, animationContext, animation, event, babylonAnimationGroup) {\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\n            return Promise.resolve();\n        }\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n        const emitterIndex = event.emitter;\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\n        return this._loadEmitterAsync(context, emitter).then(() => {\n            const sound = emitter._babylonData.sound;\n            if (sound) {\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\n                // Make sure all started audio stops when this animation is terminated.\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\n                    sound.stop();\n                });\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\n                    sound.pause();\n                });\n            }\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_audio_emitter(loader));\n//# sourceMappingURL=MSFT_audio_emitter.js.map"],"names":["AnimationEvent","frame","action","onlyOnce","WeightedSound","loop","sounds","weights","weightSum","weight","invWeightSum","i","sound","value","Logger","startOffset","randomValue","total","NAME","MSFT_audio_emitter","loader","extensions","extension","ArrayItem","context","scene","GLTFLoader","extensionContext","promises","emitterIndex","emitter","node","assign","babylonMesh","Vector3","Tools","animation","babylonAnimationGroup","event","clip","promise","bufferView","data","clipPromises","name","options","clipContext","objectURL","Sound","weightedSound","time","currentFrame","frameOffset","animationContext","babylonAnimation","babylonAnimationEvent","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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","x_google_ignoreList":[0,1,2]}